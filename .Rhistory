global = global + 1
toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
outlier_woodDeck = subset(temp, temp[,attrib]>graph$stats[5]|temp[,attrib]<graph$stats[1])
gg = gg+1
outers[gg] = attrib
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
#global = global + 1
#toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
outlier_openPorch = subset(temp, temp[,attrib]>graph$stats[5]|temp[,attrib]<graph$stats[1])
gg = gg+1
outers[gg] = attrib
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
#global = global + 1
#toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
global = global + 1
toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
outlier_X3Ss = subset(temp, temp[,attrib]>graph$stats[5]|temp[,attrib]<graph$stats[1])
gg = gg+1
outers[gg] = attrib
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
#global = global + 1
#toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
outlier_screenPorch = subset(temp, temp[,attrib]>graph$stats[5]|temp[,attrib]<graph$stats[1])
gg = gg+1
outers[gg] = attrib
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
#global = global + 1
#toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
outlier_poolarea = subset(temp, temp[,attrib]>graph$stats[5]|temp[,attrib]<graph$stats[1])
gg = gg+1
outers[gg] = attrib
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
#global = global + 1
#toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
global = global + 1
toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
global = global + 1
toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
global = global + 1
toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
outlier_miscVal = subset(temp, temp[,attrib]>graph$stats[5]|temp[,attrib]<graph$stats[1])
gg = gg+1
outers[gg] = attrib
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
#global = global + 1
#toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
#global = global + 1
#toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
#global = global + 1
#toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
global = global + 1
toremove[global] = attrib
}
attrib = attrib + 1
colname[attrib]
if (typeof(temp[,attrib]) == 'integer' ||(typeof(temp[,attrib]) == 'double')){
graph = boxplot(temp[,attrib])
print(length(graph$out))
print(graph$out)
outlierID = which(temp[,attrib]>graph$stats[5],)
temp[outlierID,]
}
if (typeof(temp[,attrib]) == 'character'){
print(as.data.frame(table(temp[,attrib])))
print(ggplot(data = temp, aes(x=temp[,attrib], y=temp$SalePrice)) + geom_boxplot(aes(fill = factor(temp[,attrib]) )) +scale_x_discrete(name = (colname[attrib])) + labs(fill = (colname[attrib])))
#global = global + 1
#toremove[global] = attrib
}
print("The following attributes are under review to be removed:")
colname[toremove]
print("The following attributes have outliers that need to be addressed:")
colname[outers]
#The ruleset I am emplaying is if there is one variable with over 65% of the observations or 2 with over 70%, I shall remove the attribute based of low variance.
temp[toremove] <- NULL
#Subsetting for numeric only
nums <- unlist(lapply(temp, is.numeric))
numONLY = temp[,nums]
aa<-cor(numONLY)
ggcorrplot(aa)
#We are only intrested in the Sales price of the matrix
aa[,26]
#Might be better for us to remove 4 attributes and create a fuller 1 attribute
temp$HouseArea <- temp$TotalBsmtSF + temp$X1stFlrSF + temp$X2ndFlrSF
# Undo some work from before for this stage.
temp$FullBath <- as.numeric(temp$FullBath)
temp$BsmtFullBath <- as.numeric(temp$BsmtFullBath)
temp$HalfBath <- as.numeric(temp$HalfBath)
temp$BsmtHalfBath <- as.numeric(temp$BsmtHalfBath)
# Why keep so many bathroom attributes. Let us condense instead.
temp$TotalBath <- temp$FullBath + 0.5*(temp$HalfBath) + temp$BsmtFullBath + 0.5*as.numeric(temp$BsmtHalfBath)
# Same with porch
temp$TotalPorchSF <- temp$OpenPorchSF + temp$EnclosedPorch + temp$X3SsnPorch + temp$ScreenPorch + temp$WoodDeckSF
# Lets include the garage now
temp$TotalArea <-temp$HouseArea + temp$GarageArea
#We also know that total basement SF = BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF. WHy not remove it
#Another reason so remove total basement SF is because of its high correlation to 1stFlrSF
temp$TotalBsmtSF <- NULL
#Do not need house area, if we have total area
temp$HouseArea <- NULL
temp$OverallQual <- NULL
temp$GrLivArea <- NULL
temp$GarageArea <- NULL
temp$X1stFlrSF <-NULL
temp$X2ndFlrSF <- NULL
temp$FullBath <- NULL
temp$HalfBath <-NULL
temp$BsmtFullBath <- NULL
temp$BsmtHalfBath <- NULL
temp$OpenPorchSF <- NULL
temp$EnclosedPorch <- NULL
temp$X3SsnPorch <- NULL
temp$ScreenPorch <- NULL
temp$WoodDeckSF <- NULL
temp$PoolArea <- NULL
colname_new <- colnames(temp)
colname_new
#Only intrested in the attributes we added, but lets take a look
nums <- unlist(lapply(temp, is.numeric))
numONLY = temp[,nums]
aa<-cor(numONLY)
ggcorrplot(aa)
#We are only intrested in the Sales price of the matrix
aa[,15]
diag(var(numONLY))
#Lets look at Lot
plot(temp$LotFrontage, temp$LotArea)
ggplot(data = temp, aes(y=temp$LotFrontage, x=temp$LotShape)) + geom_jitter(aes((temp$LotShape) ))
plot(temp$TotalBath,temp$SalePrice)
plot(temp$TotalArea,temp$SalePrice)
plot(temp$GarageCars, temp$SalePrice)
plot(temp$YearBuilt, temp$SalePrice)
plot(temp$YearRemodAdd, temp$SalePrice)
#These attributes had the highest correlation with sales price. It is evident in these plot.
#Something else we can see from the last prompts is that larger homes would have more bathrooms, and in turn higher prices.
qplot(temp$TotalArea,temp$SalePrice, data = temp, colour= temp$TotalBath)
#Larger homes would also have better quality fireplaces.
qplot(temp$TotalArea,temp$SalePrice, data = temp, colour= temp$FireplaceQu)
#And better exterior quality
qplot(temp$TotalArea,temp$SalePrice, data = temp, colour= temp$ExterQual)
#And better Basement quality
qplot(temp$TotalArea,temp$SalePrice, data = temp, colour= temp$BsmtQual)
#QUality in general makes for a better house price
qplot(temp$ExterQual,temp$SalePrice, data = temp, colour= temp$BsmtQual)
# Very imporant comparisons, used to make decisions. Great to find patterns
ggplot(data = temp, aes(x=temp$ExterQual, y=temp$SalePrice)) + geom_count(aes( factor(temp$ExterQual) ))
ggplot(data = temp, aes(x=temp$KitchenQual, y=temp$SalePrice)) + geom_count(aes(factor(temp$KitchenQual) ))
ggplot(data = temp, aes(x=temp$BsmtQual, y=temp$SalePrice)) + geom_count(aes(factor(temp$BsmtQual) ))
ggplot(data = temp, aes(x=temp$FireplaceQu, y=temp$SalePrice)) + geom_count(aes(factor(temp$FireplaceQu) ))
#ggplot(data = temp, aes(x=temp$Fireplace, y=temp$SalePrice)) + geom_count(aes((temp$Fireplace) ))
qplot(temp$Fireplaces,temp$SalePrice, data = temp)
ggplot(data = temp, aes(x=temp$MiscVal, y=temp$SalePrice)) + geom_count(aes((temp$MiscVal) ))
ggplot(data = temp, aes(x=temp$BsmtFinSF1, y=temp$SalePrice)) + geom_count(aes((temp$BsmtFinSF1) ))
ggplot(data = temp, aes(x=temp$BsmtFinSF2, y=temp$SalePrice)) + geom_count(aes((temp$BsmtFinSF2) ))
ggplot(data = temp, aes(x=temp$BsmtFinType2, y=temp$SalePrice)) + geom_count(aes((temp$BsmtFinType2) )) #This got through the cracks, it should have been removed.
ggplot(data = temp, aes(x=temp$MasVnrArea, y=temp$SalePrice)) + geom_count(aes((temp$MasVnrArea) ))
ggplot(data = temp, aes(x=temp$MasVnrType, y=temp$SalePrice)) + geom_count(aes((temp$MasVnrType) ))
ggplot(data = temp, aes(x=temp$BsmtUnfSF, y=temp$SalePrice)) + geom_count(aes((temp$BsmtUnfSF) ))
mean(temp$BsmtUnfSF)
nrow(temp[temp$BsmtUnfSF<200,])#I decide to keep this, attribute
ggplot(data = temp, aes(x=temp$LowQualFinSF, y=temp$SalePrice)) + geom_count(aes((temp$LowQualFinSF) ))
ggplot(data = temp, aes(x=temp$GarageCars, y=temp$SalePrice)) + geom_count(aes((temp$GarageCars) ))
ggplot(data = temp, aes(x=temp$LotFrontage, y=temp$SalePrice)) + geom_count(aes((temp$LotFrontage) ))
nrow(temp[temp$LotFrontage<10,])#I decide to keep this, attribute
ggplot(data = temp, aes(x=temp$tot, y=temp$SalePrice)) + geom_count(aes((temp$LotFrontage) ))
mean(temp$PoolArea)
mean(temp$MiscVal)
mean(as.numeric(temp$Fireplaces))
#After observing the graphics and looking into variances and mean, these need to be removed. The means alone tell a story of how skewed of a picture these give. Because of a lack of normalization, means can show a picture as well.
temp$Fireplace <- NULL
temp$PoolArea <- NULL
temp$MiscVal <- NULL
temp$BsmtFinSF2 <- NULL
temp$MasVnrArea <- NULL
temp$LowQualFinSF <-NULL
#bsmtfinsf1
flattened_outlier = unlist(outlier_bsmtFinSF1[1], use.names = FALSE)
temp = subset(temp, !(temp$Id %in% flattened_outlier))
#removed bsmtfinsf2
outlier_bsmtFinSF2 = 0
#removed masvnrarea
outlier_masVnrArea = 0
#bsmtUnfSF
flattened_outlier = unlist(outlier_bsmtUnfSF[1], use.names = FALSE)
temp = subset(temp, !(temp$Id %in% flattened_outlier))
#removed garage area
outlier_garageArea = 0
#removed garage car
flattened_outlier = unlist(outlier_garagecars[1], use.names = FALSE)
temp = subset(temp, !(temp$Id %in% flattened_outlier))
#removed grlivarea
outlier_grLivArea = 0
#lotarea
flattened_outlier = unlist(outlier_lotArea[1], use.names = FALSE)
temp = subset(temp, !(temp$Id %in% flattened_outlier))
#lotfrontage
flattened_outlier = unlist(outlier_lotFrontage[1], use.names = FALSE)
temp = subset(temp, !(temp$Id %in% flattened_outlier))
#removed lowqualfin
outlier_lowQualFinSF = 0
#removed misc
outlier_miscVal = 0
#removed OpenPorch
outlier_openPorch = 0
#removed pool
outlier_poolarea = 0
#removed screen porch
outlier_screenPorch= 0
#removed total Basement SF
outlier_totalBsmtSF= 0
#removed wood deck
outlier_woodDeck= 0
#removed 1st flr sf
outlier_x1stFlrSF= 0
#removed 2nd flr sf
outlier_x2stFlrSF= 0
#removed 3Ss
outlier_X3Ss= 0
print("it is a good idea we waited to remove the outliers, otherwise we would have lost a lot of observations only to remove the attributes later")
#I will allow this outliers:
#outlier_yearbuilt
#after all our intial analysis, we can set the data back to our original name
modified_data = temp
modified_data = subset(modified_data, select=-c(SalePrice))
modified_data$SalePrice = temp$SalePrice
modified_data <- droplevels(modified_data)
# Our Normalizing technique
normalize <- function(x) {
if (is.numeric(x)){
return ((x - min(x)) / (max(x) - min(x))) }
else{
return (x)
}
}
data_norm = as.data.frame(lapply(modified_data[2:40], normalize))
data_norm <- cbind(modified_data$SalePrice, data_norm)
colnames(data_norm)[colnames(data_norm)=="modified_data$SalePrice"] <- "SalePrice"
data_norm_noout <- subset(data_norm, data_norm$SalePrice < boxplot(data_norm$SalePrice)$stats[5,])
numsonly <- unlist(lapply(modified_data, is.numeric))
numarray = temp[,numsonly]
numarray = subset(numarray, select = -c(Id))
fit = kmeans(numarray,4)
plotcluster(numarray,fit$cluster)
#str(fit)
fit = kmodes(numarray, 4)
plotcluster(numarray,fit$cluster)
# It is not meaningful to have clustering for categorical variables. I did only numerical values.
set.seed(11)
#Splitting training to 80%, test to 20%
index <- sample(1:nrow(data_norm_noout), 0.80 *nrow(data_norm_noout))
data_train <- data_norm[index,]
data_test <- data_norm[-index,]
data_train_noout <- data_norm_noout[index,]
data_test_noout <- data_norm_noout[-index,]
rf_data = modified_data
rf_data$GarageYrBlt = unlist(lapply(modified_data$GarageYrBlt, as.numeric), use.name = FALSE )
rf_data = subset(rf_data, select= -c(GarageYrBlt))
rdata_norm = as.data.frame(lapply(rf_data[2:40], normalize))
rdata_norm <- cbind(modified_data$SalePrice, rdata_norm)
colnames(rdata_norm)[colnames(rdata_norm)=="modified_data$SalePrice"] <- "SalePrice"
# training to 80%, test to 20%
index <- sample(1:nrow(rdata_norm), 0.80 *nrow(rdata_norm))
rdata_train <- rdata_norm[index,]
rdata_test <- rdata_norm[-index,]
rdata_norm_noout <- subset(rdata_norm, rdata_norm$SalePrice < boxplot(rdata_norm$SalePrice)$stats[5,])
# training to 80%, test to 20%
index <- sample(1:nrow(rdata_norm_noout), 0.80 *nrow(rdata_norm_noout))
rdata_train_noout <- rdata_norm_noout[index,]
rdata_test_noout <- rdata_norm_noout[-index,]
#Our label is the Sales price, in col 1
# trainlabel <- data_train[,1]
# testlabel <- data_test[,1]
#Applying KNN
##test_pred <- knn(train = data_train[,2:39], test = data_test[,2:39],cl = data_train[,1], k=9)
#Creating accuracy matrix
##CrossTable(x=testlabel, y=test_pred, prop.chisq=FALSE) # This makes no sense for non-class prediction (i.e Regression)
set.seed(11)
tree_model <- tree(rdata_train$SalePrice ~ . , data = rdata_train)
plot(tree_model)
text(tree_model)
tree_pred = predict(tree_model, rdata_test)
MAE(rdata_test$SalePrice, tree_pred)
RMSE(rdata_test$SalePrice, tree_pred)
cv_tree = cv.tree(tree_model)
names(cv_tree)
plot (cv_tree$size, cv_tree$dev, type = "b", xlab = "Tree Size", ylab = "MSE")
cv_tree$size[which.min(cv_tree$dev)]
print("No need to prune, we are using size 9 tree")
set.seed(11)
m1 <- rpart(data_train$SalePrice ~ ., data = data_train, method = "anova")
m1
regress_plot <- rpart.plot(m1, type=2, digits=3, fallen.leaves = TRUE)
p1 <- predict(m1, data_test)
# Two error checking methods.
MAE(data_test$SalePrice, p1)
RMSE(data_test$SalePrice, p1)
set.seed(11)
model_RF<- randomForest(rdata_train$SalePrice ~ ., data = rdata_train, proximity=TRUE)
model_RF
rf_predict = predict(model_RF,rdata_test)
RMSE(rdata_test$SalePrice,rf_predict)
MAE(rdata_test$SalePrice,rf_predict)
# Increasing the tree coutn doesnt significantly decrease the errors
set.seed(11)
rregressive_model <- lm(data_train$SalePrice ~ ., data = data_train)
#summary(rregressive_model)
plot(rregressive_model)
predict_reg = predict(rregressive_model, data_test)
predict_reg = predict(rregressive_model, data_test,na.action = na.action)
predict_reg = predict(rregressive_model, data_test)
data_test$xlevels
rregressive_model$xlevels
str(data_test$Exterior2nd)
factor(data_test$Exterior2nd)
levels(data_test$Exterior2nd)
lm_subset_data_test <- subset(data_test, data_test$Exterior2nd != "Other")
predict_reg = predict(rregressive_model, lm_subset_data_test)
lm_subset_data_test <- subset(data_test, data_test$GarageYrBlt != "1900" | data_test$GarageYrBlt != "1915" | data_test$GarageYrBlt != "1929" | data_test$GarageYrBlt != "1933")
lm_subset_data_test <- subset(data_test, data_test$Exterior2nd != "Other")
lm_subset_data_test <- subset(lm_subset_data_test, data_test$GarageYrBlt != "1900" && data_test$GarageYrBlt != "1915" && data_test$GarageYrBlt != "1929" && data_test$GarageYrBlt != "1933")
predict_reg = predict(rregressive_model, lm_subset_data_test)
lm_subset_data_test <- subset(lm_subset_data_test, data_test$GarageYrBlt != "1900")
lm_subset_data_test <- subset(lm_subset_data_test, lm_subset_data_test$GarageYrBlt != "1900")
lm_subset_data_test <- subset(lm_subset_data_test, data_test$GarageYrBlt != "1900" |data_test$GarageYrBlt != "1915" |data_test$GarageYrBlt != "1929" |data_test$GarageYrBlt != "1933" |)
lm_subset_data_test <- subset(lm_subset_data_test, data_test$GarageYrBlt != "1900" |data_test$GarageYrBlt != "1915" |data_test$GarageYrBlt != "1929" |data_test$GarageYrBlt != "1933")
lm_subset_data_test <- subset(lm_subset_data_test, lm_subset_data_test$GarageYrBlt != "1900" |lm_subset_data_test$GarageYrBlt != "1915" |lm_subset_data_test$GarageYrBlt != "1929" |lm_subset_data_test$GarageYrBlt != "1933")
predict_reg = predict(rregressive_model, lm_subset_data_test)
rregressive_model <- lm(rdata_train$SalePrice ~ ., data = rdata_train)
predict_reg = predict(rregressive_model, rdata_test)
plot(rregressive_model)
predict_reg = predict(rregressive_model, rdata_test, droplevels(rdata_test))
levels(rdata_train)
levels(rdata_train$MSSubClass)
levels(rdata_train[])
levels(rdata_train[,])
str(rdata_train)
sapply(rdata_train, levels)
some = subset(rdata_train, sapply(rdata_train, levels) == sapply(rdata_test, levels))
unique(rdata_train)
## ## PROBLEM HERE BECAUSE THERE ARE CASES WHERE FACTORS IN TEST ARE NOT PRESENT IN TRAINING
set.seed(11)
rregressive_model <- lm(rdata_train$SalePrice ~ ., data = rdata_train)
#summary(rregressive_model)
plot(rregressive_model)
predict_reg = predict(rregressive_model, newdata =  rdata_test)
boxplot(data_norm_noout$SalePrice)$out
boxplot(data_norm$SalePrice)$out
boxplot(data_norm$SalePrice)$stats[5,]
boxplot(data_norm$SalePrice)$stats[4,]
View(data_test_noout)
